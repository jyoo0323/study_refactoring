# Ch 3 코드에서 나는 악취

- `적용 방법` 을 아는 것과 `제때 적용` 할 줄 하는 것은 다르다.
- 인스턴스 변수의 삭제 & 상속 계층을 만드는 방법은 알아도, 그걸 `언제` 해야 하는지에 대한 명확한 규칙은 없다.

### 3.1 기이한 이름 (Mysterious Name)

- 코드를 명료하게 표현하는 데 가장 중요한 요소 중 하나 ⇒ 이름
    - 이름만 보고도 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.
- 프로그래밍에서 가장 어려운 두 가지: 1. 네이밍 2. 캐시 무효화 (cache invalidation)
    - 필 칼튼이라는 개인이 한 말이지만, 많은 사람들이 공감한다고 한다.
- **좋은 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다**
    - 이름을 잘 정리하는 것으로도 코드가 간결해질 때가 많다.

### 3.2 중복 코드 (Duplicated Code)

- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 ⇒ 함수 추출하기를 통해 양쪽에서 추출한 메서드를 사용하도록 변경.
- 코드가 비슷하나 똑같진 않다면 문장 슬라이드하기로 비슷한 부분을 한곳에 모아 함수 추출하기를 쉽게 적용하게 만들 수 있다
- 서브 클래스들에 코드가 중복되어 있다면, 메서드 올리기를 적용해 부모로 옮겨 따로 호출되지 않게 만들 수 있다.

### 3.3 긴 함수 (Long Function)

- 함수를 짧게 만들어 끝없이 위임하는 방식으로 만들게 되면 **간접 호출의 효과를 얻는데,** 이는 코드를 이해하고 공유하고, 선택하기 쉬워진다는 장점을 가져온다
- 함수를 짧게 유지하고, 호출하는 함수명을 간결하고 명확히 지으면 해당 코드의 이해는 쉬워진다.
    - *질문: 가끔 코드를 보다보면 짧게 작성하고 호출을 연달아 하는데, 까보다보면 함정이 섞여있는 경우가 있다. 이런 경우를 빠르게 파악할 수 있는 방법은 있을까? → 개인적으로는 그런 방법은 불가능하지 않나..*
- **저자의 방식: 주석을 달만한 로직 ⇒ 무조건 별도의 함수화.**
- 함수의 이름은 동작 방식이 아닌 의도 (intention)이 드러나게 짓는다.
    - **원래 코드보다 길어지더라도 함수로 뽑는다.**
- **함수를 짧게 만드는 작업의 99.9% == 함수 추출하기!**
- 임시변수가 많다 ⇒ 추출한 함수에도 매개변수가 너무 많아져서 리팩터링 전보다 난해해질 수 있다.
    - 이 경우 임시 변수를 질의 함수로 바꾸기를 통해 임시 변수의 수를 줄이고
    - 매개변수 객체 만들기와 객체 통째로 넘기기를 이용해 매개변수의 수를 줄일 수 있을 것이다.
    - 이후에도 여전히 임시변수와 매개변수가 너무 많다면 함수를 명령으로 바꾸기를 고려해야한다.
- 조건문 ⇒ 조건문 분해하기로 대응하여 분해
- 거대한 Switch 문은 각 case 를 함수 추출하기로 나눈 후, 같은 조건을 기준으로 나뉘는 switch 문이 여러 개라면 조건부 로직을 다형성으로 바꾸기를 적용.
- <details>
  <summary>GPT 예제</summary>
    <li>리팩터링 전

  ```java
  public class Employee {
  private final String type;

      public Employee(String type) {
          this.type = type;
      }

      public double calculateBonus(double salary) {
          switch (type) {
              case "Manager":
                  return salary * 0.2;
              case "Developer":
                  return salary * 0.1;
              case "Intern":
                  return salary * 0.05;
              default:
                  throw new IllegalArgumentException("Invalid employee type");
          }
      }

      public String getResponsibilities() {
          switch (type) {
              case "Manager":
                  return "Manage team and projects";
              case "Developer":
                  return "Write and maintain code";
              case "Intern":
                  return "Assist developers and learn";
              default:
                  throw new IllegalArgumentException("Invalid employee type");
          }
      }
  }
  ```
  </li>
  <li>리팩터링 후

    ```java
            public abstract class Employee {
                public abstract double calculateBonus(double salary);
                public abstract String getResponsibilities();
            }
            
            public class Manager extends Employee {
                @Override
                public double calculateBonus(double salary) {
                    return salary * 0.2;
                }
            
                @Override
                public String getResponsibilities() {
                    return "Manage team and projects";
                }
            }
            
            public class Developer extends Employee {
                @Override
                public double calculateBonus(double salary) {
                    return salary * 0.1;
                }
            
                @Override
                public String getResponsibilities() {
                    return "Write and maintain code";
                }
            }
            
            public class Intern extends Employee {
                @Override
                public double calculateBonus(double salary) {
                    return salary * 0.05;
                }
            
                @Override
                public String getResponsibilities() {
                    return "Assist developers and learn";
                }
            }
            
            public class EmployeeFactory {
                public static Employee createEmployee(String type) {
                    switch (type) {
                        case "Manager": return new Manager();
                        case "Developer": return new Developer();
                        case "Intern": return new Intern();
                        default: throw new IllegalArgumentException("Invalid employee type");
                    }
                }
            }
    ```

  </li>
  - 예시만보면 수정전이 훨씬 더 간결해 보이기는 하지만, 객체 레벨로 분해되어 훨씬 더 OOP스러워진 것을 느낄 수 있다.

</details>

### 3.4 긴 매개변수 목록 (Long Parameter List)

- 다른 매개 변수에서 값을 얻어 올 수 있는 매개변수 ⇒ 매개변수를 질의 함수로 바꾸기로 제거 가능
- 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 객체 통쨰로 넘기기를 통해 원본 데이터 구조를 그대로 전달
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기로 없애 준다.
- 클래스를 활용해 매개변수 목록을 효과적으로 줄일 수 있다.
    - 여러 함수가 특정 매개변수들의 값을 공통으로 사용하는 경우 여러 함수를 클래스로 묶기를 이용해 공통 값들을 클래스의 필드로 정의한다.

### 3.5 전역 데이터 (Global Data)

- 전역 데이터의 문제는 코드베이스 어디에서든 건드릴 수 있고, 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 것이 문제.
    - 마치 유령 같은 원격 작용 (spooky action at a distance) 처럼 버그를 양산하나 원인은 찾기가 어려운 상태가 된다.
- 보통은 전역 변수를 의미하지만, 클래스 변수와 싱글톤에서도 문제가 발생할 수 있다.
- 특히 문제가 되는 것이 가변가능한 데이터일 경우.
    - EX: 웹소켓 세션 데이터의 목록을 클래스 변수로 들고 있는 경우.
- 이러한 전역 데이터의 문제를 방지하기 위해 사용할 수 있는 대표적인 방법이 변수 캡슐화하기
    - 다른 코드에서 오염 시킬 수 있는 데이터를 함수로 감싸는 것 만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.

### 3.6 가변 데이터 (Mutable Data)

- 변수 캡슐화하기를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉬워짐.
- 이 부분은 아주 다양한 방법을 이용해 리팩터링이 가능하나.. 너무 특정 상황에서 적용하는 예시가 많아 예시를 봐가며 직접 해보는 경험이 중요해 보인다.

### 3.7 뒤엉킨 변경 (Divergent Change)

- 단일 책임 원칙 (Single Responsibility Principle)이 제대로 지켜지지 않았을 때 나타나는 이슈로 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생.
    - 예를 들어 지원해야 할 데이터베이스가 추가될 때마다 함수 세 개를 바꿔야 하고, 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야 하는 모듈이 있다면 변경이 발생했다는 의미.
    - 데이터베이스 연동과 금융 상품 처리는 서로 다른 맥락(Context)에서 이뤄지므로 독립된 모듈로 분리해야 프로그래밍이 편하다.

### 3.8 산탄총 수술 (Shotgun Surgery)

- 3.7 (뒤엉킨 변경) 과 유사한 듯 정반대이다.
    - 원인과 해결 방법은 유사하나, 문제의 발생과정과 구체적인 해결 방법이 정반대라고 함.
    - 즉 단순히 말하자면, 하나의 수정을 만들기 위해 여러 작은 수정을 많은 클래스에 가해야 하는 상황을 말하는데 그 중 발생의 원인이 여러 코드에 난잡하게 뿌려진 케이스 이고, 이를 해결하는 방식이 맥락별로 모은는 경우이다.

- 해결 방법 예시:
    - 함께 변경되는 대상들을 함수 옮기기 + 필드 옮기기를 통해 한 모듈로 묶는다.
    - 비슷한 데이터를 다루는 함수가 많다면 여러 함수를 클래스로 묶기 적용
    - 데이터 구조를 변환하거나 보강하는 함수들에는 여러 함수를 변환 함수로 묶기 적용
    - 이후 단계 쪼개기 적용
- <details>
  <summary>Copilot의 예제</summary>

    <li>리팩터링 전

  ```java
    public class Customer {
        private String name;
        private String address;

        public void updateAddress(String newAddress) {
            this.address = newAddress;
        }
     }

  public class Order {
  private String orderNumber;
  private String shippingAddress;

        public void updateShippingAddress(String newAddress) {
            this.shippingAddress = newAddress;
        }
  }

  public class Invoice {
  private String invoiceNumber;
  private String billingAddress;

        public void updateBillingAddress(String newAddress) {
            this.billingAddress = newAddress;
        }
  }

  ```
    </li>
    <li>리팩터링 후

  ```java

// 주소 관련 로직을 캡슐화한 Address 클래스
public class Address {
private String address;

    public Address(String address) {
        this.address = address;
    }

    public void updateAddress(String newAddress) {
        this.address = newAddress;
    }

    public String getAddress() {
        return address;
    }

}

// Address 를 필드로 활용하여 주소 관련 로직을 Address를 이용하여 처리하도록 변경

public class Customer {
private String name;
private Address address;

    public Customer(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    public void updateAddress(String newAddress) {
        this.address.updateAddress(newAddress);
    }

}

public class Order {
private String orderNumber;
private Address shippingAddress;

    public Order(String orderNumber, Address shippingAddress) {
        this.orderNumber = orderNumber;
        this.shippingAddress = shippingAddress;
    }

    public void updateShippingAddress(String newAddress) {
        this.shippingAddress.updateAddress(newAddress);
    }

}

public class Invoice {
private final String invoiceNumber;
private final Address billingAddress;

    public Invoice(String invoiceNumber, Address billingAddress) {
        this.invoiceNumber = invoiceNumber;
        this.billingAddress = billingAddress;
    }

    public void updateBillingAddress(String newAddress) {
        this.billingAddress.updateAddress(newAddress);
    }

}

```
  </li>

</details>

### 3.9 기능 편애 (Feature Envy)

- 프로그램을 모듈화 할 때 ⇒ 여러 영역으로 나눈 뒤 영역 안에서의 상호작용을 최대한 늘리고 영역 사이에서의 상호작용은 최소화
    - 각 영역간의 분리 (SRP)를 지키려는 노력
- 기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 발생
- 예시:
    - 실행 과정에서 외부 객체의 게터 메서드 대여섯개를 호출하는 함수 ⇒ 함수 옮기기를 사용해 필요한 데이터 근처로 이동
    - 함수의 일부에서만 편애가 일어나는 경우 ⇒ 그 부분을 독립 함수로 분리 (함수 추출하기) && 필요한 모듈로 이전 (함수 옮기기)

### 3.10 데이터 뭉치 (Data Clumps)

- 뭉쳐다니는 데이터 조합을 의미하고, 특정 클래스 등에서 이러한 세트가 뭉쳐다니는 경우에 어찌할 것인지를 의미한다.
- 뭉쳐있는 데이터 세트를 찾아내 클래스 추출하기로 하나의 객체로 묶어 클래스로 변경
- 이후 매개변수 객체 만들기 / 객체 통째로 넘기기를 사용해 기존 필드를 대체
- Copilot의 예시

    ```java
    // 리팩터링 이전 고객 관련한 데이터들이 하나로 뭉쳐있는 모습
    public class Order {
        private String customerName;
        private String customerAddress;
        private String customerPhone;
    
        public void printCustomerDetails() {
            System.out.println("Name: " + customerName);
            System.out.println("Address: " + customerAddress);
            System.out.println("Phone: " + customerPhone);
        }
    
        public void updateCustomerDetails(String name, String address, String phone) {
            this.customerName = name;
            this.customerAddress = address;
            this.customerPhone = phone;
        }
    }
    ```

  ```java
  // Customer 라는 클래스를 Order로 부터 분리
  @Getter
  @AllArgsConstructor
  public class Customer {
      private String name;
      private String address;
      private String phone;
      
      public void updateDetails(String name, String address, String phone) {
          this.name = name;
          this.address = address;
          this.phone = phone;
      }
  }
  
  public class Order {
      private final Customer customer;
  
      public Order(Customer customer) {
          this.customer = customer;
      }
  
      public void printCustomerDetails() {
          System.out.println("Name: " + customer.getName());
          System.out.println("Address: " + customer.getAddress());
          System.out.println("Phone: " + customer.getPhone());
      }
  
      public void updateCustomerDetails(String name, String address, String phone) {
          customer.updateDetails(name, address, phone);
      }
  }

  ```

### 3.11 기본형 집착 (Primitive Obsession)

- 프로그래머 중엔 문제에 맞는 기초 타입 (ex: 화폐, 좌표, 구간 등)을 직접 정의하지 않고 그냥 숫자형 (int, long 등) 물리량을 계산할 때도 밀리미터 등의 단위를 무시하고 경우
    - 로직의 도메인화
    - 문자열을 다룰 시 특히 많이 발생하며, 마틴 파울러의 의견에는 최소 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이 있어야 한다고 함.
        - Ex: 전화번호를 단순 스트링으로 저장하기 보단, 그를 위한 클래스를 만들고 저장해 두다 원하는 형태로 리턴할 수 있게 만드는 방법
    - 이러한 케이스를 문자열화된 변수(stringly typed variable)라고 부르기도 한다
- 기본형을 객체로 바꾸기를 적용 → 만일 해당 코드가 조건부 로직을 담당하는 타입 코드일 경우 타입 코드를 서브 클래스로 바꾸기 + 조건부 로직을 다형성으로 바꾸기를 적용한다.
- 자주 3.10 데이터 뭉치와 함께 발생한다, 연결되는 해결 방법을 적용하면 좋다.

### 3.12 반복되는 Switch문 (Repeated Switches)

- 순수한 객체 지향 신봉자들의 의견: Switch는 악이요, if문까지도 다형성을 통해 분기할 수 있게 해야한다
    - 초판때문에 오해를 산 것 같으나, 저자의 의도는 switch가 무조건 적인 악은 아닌 듯 하다. (이러한 의견은 언어의 발전도 한몫하는 듯)
- 중복된 switch 의 문제는, 조건절 하나 추가할 때마다 다른 switch 문들도 모두 함께 수정이 되어야 하기 때문이라고 한다.

### 3.13 반복문 (Loops)

- 지금은 유행이 지난 안좋은 방법!
- 일급 함수 (first-class function) 을 지원하는 언어 등에서는 반복문을 파이프라인으로 바꾸기를 적용해 제거가 가능함.
    - 자바의 람다를 이용하는 방법으로 처리

### 3.14 성의 없는 요소 (Lazy Element)

- 메서드, 클래스, 인터페이스 등 코드 구조를 잡는데 활용되는 요소가 필요 없이 적용되어 있는 경우.
- 대부분 원래 계획은 미리 만들어두고 추후에 추가해가는 구조를 생각하고 미리 만들어 두었으나, 계획의 변경등 다양한 사정으로 그렇게 되지 못한 결과일 수 있다.
- 이 경우 함수 인라인하기 / 클래스 인라인하기 등으로 제거가능.
- 상속이 적용된 케이스라면 계층 합치기를 적용

### 3.15 추측성 일반화 (Speculative Generality)

- ‘나중에 필요할 거야~’ 라는 생각으로 온갖 후킹 포인트 특이 케이스 처리 로직을 작성해둔 코드
    - 그 결과로 오히려 이해 + 관리하기만 어려워졌을 경우
- 불필요한 추상 클래스는 계층 합치기로 제거
- 쓸데없는 위임 코드는 함수 인라인하기 / 클래스 인라인하기 등으로 제거
- 사용되지 않는 매개변수는 함수 선언 바꾸기로 제거

### 3.16 임시 필드 (Temporary Field)

- 특정 상황에서만 값이 채워지는 필드를 가진 클래스.
    - 하지만 해당 클래스의 객체를 사용할 때는 당연히 모든 필드가 존재할 거라 생각하는 것이 보통이기에, 플로우의 파악이 어려워진다.
- 이러한 필드를 발견하면 클래스 추출하기를 통해 변경하고, 기존 클래스의 함수중 임시 필드에 의존하고 있는 모든 함수를 함수 옮기기를 이용해 신규 클래스로 이전한다.
- 임시 필드들의 유효성을 검증하는 로직이 있는 경우, 특이 케이스 추가하기를 통해 유효하지 않은 케이스를 위한 대안 클래스를 만들어서 제거할 수 있다.

### 3.17 메시지 체인 (Message Chain)

- 객체의 사용처에서, 그 객체의 내부 객체의 … 내부 객체를 조회에서 사용하는 경우
    - getter 가 난무하는 계층구조 하위에 있는 값을 가져오는 경우
    - 이 경우 임시 변수들이 줄줄이 나열되는 코드가 된다.
    - 이는 클라이언트가 객체 네비게이션 구조에 종속되었음을 의미한다. 그렇기에 내비게이션 중간 단계를 수정할 시 클라이언트까지 수정해야하는 문제가 발생한다.
- 위임 숨기기를 통해 해결이 가능하다.
    - 하지만 중간 객체들이 모두 중개자가 되는 문제가 발생할 수 있음 ⇒ 최종 결과 객체가 어떻게 쓰이는 지 파악해야함
- Copilot 의 예제

    ```java
    import javax.persistence.*;
    
    @Entity
    public class Address {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String street;
        private String city;
    
        // Getters and setters
        public String getCity() {
            return city;
        }
    }
    
    @Entity
    public class Customer {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        @OneToOne(cascade = CascadeType.ALL)
        private Address address;
    
        // Getters and setters
        public Address getAddress() {
            return address;
        }
    }
    
    @Entity
    public class Order {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        @ManyToOne(cascade = CascadeType.ALL)
        private Customer customer;
    
        // Getters and setters
        public Customer getCustomer() {
            return customer;
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            // Assuming order is fetched from the database
            Order order = fetchOrderFromDatabase();
    
            // Message chain
            String city = order.getCustomer().getAddress().getCity();
            System.out.println("City: " + city);
        }
    
        private static Order fetchOrderFromDatabase() {
            // Mock method to simulate fetching an order from the database
            Address address = new Address();
            address.setCity("Springfield");
    
            Customer customer = new Customer();
            customer.setAddress(address);
    
            Order order = new Order();
            order.setCustomer(customer);
    
            return order;
        }
    }
    ```

    ```java
    import javax.persistence.*;
    
    @Entity
    public class Address {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String street;
        private String city;
    
        // Getters and setters
        public String getCity() {
            return city;
        }
    }
    
    @Entity
    public class Customer {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        @OneToOne(cascade = CascadeType.ALL)
        private Address address;
    
        // Getters and setters
        public Address getAddress() {
            return address;
        }
    }
    
    @Entity
    public class Order {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        @ManyToOne(cascade = CascadeType.ALL)
        private Customer customer;
    
        // Getters and setters
        public Customer getCustomer() {
            return customer;
        }
    
        // New method to get the customer's city directly
        public String getCustomerCity() {
            return customer.getAddress().getCity();
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            // Assuming order is fetched from the database
            Order order = fetchOrderFromDatabase();
    
            // Direct method call
            String city = order.getCustomerCity();
            System.out.println("City: " + city);
        }
    
        private static Order fetchOrderFromDatabase() {
            // Mock method to simulate fetching an order from the database
            Address address = new Address();
            address.setCity("Springfield");
    
            Customer customer = new Customer();
            customer.setAddress(address);
    
            Order order = new Order();
            order.setCustomer(customer);
    
            return order;
        }
    }
    ```

### 3.18 중개자 (Middle Man)

- 위임이 지나쳐 클래스가 제공하는 메서드 중 절반 가량이 다른 클래스에 구현을 위임하고 있는데 상속 객체가 아닌 경우
- 중개자 제거하기를 활용하여 실제로 일을 하는 객체와 직접 소통하게 변경
- *질문: 중개자 제거와 메시지 체인은 때때로 완전히 상반되는 작업일 수도 있을 것 같은데 이러면 하나를 하다 다시 보니 내가 리팩터링한 내용을 다시 수정하게 되는 것은 아닌지?*

### 3.19 내부자 거래 (Insider Trading)

- 모듈간 데이터 거래가 많아지면 결합도 (coupling)이 늘어나게 되는 문제가 있음
- 타 모듈간 데이터를 주고받는 경우가 있다면 함수 옮기기와 필드 옮기기를 적용해 떼어놓는다
- 여러 모듈이 같은 관심사를 공유하는 경우, 공통 부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 위임 숨기기를 통해 다른 모듈이 중간자 역할을 하게 만든다.
- 상속구조에선 부모 자식 사이에 결탁이 생길 때가 있고, 자식 클래스는 부모 클래스가 공개하는 것 이상으로 요구하는 경우가 있고, 이런 상황이 생길 시 서브클래스 위임으로 변경 || 슈퍼클래스를 위임으로 변경을 활용해 처리

### 3.20 거대한 클래스 (Large Class)

- 거대한 클래스는 필드를 엄청나게 들고 있게 되고, 이러면 중복 코드가 생기기 쉬워진다
- 클래스 추출하기를 통해 필드를 일부 따로 묶는다
    - 만일 원래 클래스와 상속관계를 만들 수 있다면 ⇒ 슈퍼클래스 추출하기 || 타입 코드를 서브 클래스로 바꾸기 (실질적으론 서브클래스 추출하기에 해당함)
    - 클래스가 항시 모든 필드를 사용하지는 않을 수도 있다. → 이 경우 위 스텝을 여러 차례 수행
- 단순 필드가 많은 클래만이 아니라, 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 큼
    - 그 자체적으로 중복을 제거하는 것이 최선

### 3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)

- 제목 그대로의 내용! 다른 클래스이나, 인터페이스화하여 공통으로 묶을 수 있게 만드는 작업
- Copilot의 예제

    ```java
    public class OldPaymentProcessor {
        public void processPayment(double amount) {
            System.out.println("Processing payment of $" + amount + " using OldPaymentProcessor");
        }
    }
    
    public class NewPaymentProcessor {
        public void executePayment(double amount) {
            System.out.println("Executing payment of $" + amount + " using NewPaymentProcessor");
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            OldPaymentProcessor oldProcessor = new OldPaymentProcessor();
            oldProcessor.processPayment(100.0);
    
            NewPaymentProcessor newProcessor = new NewPaymentProcessor();
            newProcessor.executePayment(200.0);
        }
    }
    ```

    ```java
    // 차이가 있던 메서드를 각 클래스에서 변경해서 추출한 인터페이스
    public interface PaymentProcessor {
        void process(double amount);
    }
    
    public class OldPaymentProcessor implements PaymentProcessor {
        @Override
        public void process(double amount) {
            System.out.println("Processing payment of $" + amount + " using OldPaymentProcessor");
        }
    }
    
    public class NewPaymentProcessor implements PaymentProcessor {
        @Override
        public void process(double amount) {
            System.out.println("Executing payment of $" + amount + " using NewPaymentProcessor");
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            PaymentProcessor oldProcessor = new OldPaymentProcessor();
            oldProcessor.process(100.0);
    
            PaymentProcessor newProcessor = new NewPaymentProcessor();
            newProcessor.process(200.0);
        }
    }
    ```

### 3.22 데이터 클래스 (Data Class)

- 데이터 클래스 = 데이터 필드와 게터/세터로만 구성된 클래스
    - DTO 등
    - [데이터 클래스 사용에 관한 레딧에서의 논쟁](https://www.reddit.com/r/Kotlin/comments/g3tghh/ddd_domain_entity_as_data_class/?rdt=53181)
- 이러한 클래스의 public 필드는 레코드 캡슐화하기 로 숨기고 세터를 제거하자
- 데이터 클래스의 존재가 엉뚱한 곳에 필요한 동작이 정의되어 있다는 신호일 수도 있다.
    - 이 경우 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선됨.
    - 예외도 존재하는데 다른 함수를 호출해 얻은 결과 레코드(데이터 객체)로는 동작 코드를 넣을 이유가 없기 때문.

### 3.23 상속 포기 (Refused Bequest)

- 서브 클래스에서 부모 클래스의 데이터나 메서드가 필요치 않은 경우 어떻게 해야할까?
- 계층 구조가 잘못된 경우:
    - 같은 계층에 서브 클래스를 하나 새로 만들고, 메서드 내리기 + 필드 내리기를 활용해 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘겨 부모에 원하는 공통된 부분만 남길 수 있다
    - **그러나 마틴 파울러와 켄트 벡은 이 방식을 권하지 않는다 (정확히는 `항상 이렇게 해야한다는 아니다`)**
        - 냄새가 심각하지 않은 경우라면, 상속을 포기했을 때 발생하는 온갖 문제를 해결하기 보다 예전 방식을 따르는게 좋다는 의견
- 서브클래스가 부모의 동작은 필요하나 인터페이스를 따르고 싶지 않을 때:
    - 서브클래스를 위임으로 바꾸기 || 슈퍼클래스를 위임으로 바꾸기를 이용해 상속 메커니즘을 벗어나야한다

### 3.24 주석 (Comments)

- 주석이 나쁜것은 아니나, 너무 장황한 주석은 오히려 코드 스멜을 증가 시킨다
- 불필요한 주석을 달아야 한다면 함수 추출하기 등으로 이해하기 쉬운 메서드를 만드는 게 좋다.
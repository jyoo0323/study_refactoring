### 2.1 리팩터링 정의

`명사`로서의 리팩터링: **`소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법`**

→ 함수 추출하기 & 조건부 로직을 다형성으로 바꾸기 등이 이에 해당

`동사` 로서의 리팩터링: `소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다`

- **단순히 코드를 정리하는 것이 아니라, 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.**

리팩터링 하다가 코드가 깨졌다 ⇒ **리팩터링을 한 것이 아니다!**

### 코드베이스 정리 & 구조 변경은 `재구성 (restructuring)` 이고, 이는 리팩터링보다 더 넓은 상위의 개념이라 봐야 한다.

리팩터링의 세분화된 프로세스는 불필요해 보일 때가 있으나, 디버깅에 시간을 뺏기지 않고 체계적이기 때문에 오히려 시간을 아낄 수 있다.

### 리팩터링 과정 중 발견된 버그도 그대로 남아 있어야 한다! ⇒ 즉 버그 수정도 리팩터링과는 분리되어야 함

⇒ 현재 회사를 기준으로 플로우를 생각해보면, 개발 → QA → 버그 수정 → 리팩터링 → 리팩터링 중 발견된 버그 수정 → 리팩터링 → QA 이런 느낌으로 진행하라는 의미인 듯 하다.

성능 최적화와 리팩터링은 다른 개념임을 주의하자. 리팩터링은 이후 동작은 동일할 지언정, 성능은 오히려 악화 될 수도 있다.

---

### 2.2 두 개의 모자

간략히 말을 하자면, 기능 추가와 리팩터링 모자가 있고, 하나를 쓰면 다른 하나는 절대 처다도 보지 말라로 해석할 수 있을 듯 하다.

즉 기능 추가를 할 때는 기존 코드를 1도 건들지 않고 작업해야하며, 새 기능을 추가하기만 해야 한다.

- 기존 기능을 건드려야만 하는 개발을 하는 경우엔??
    - ex: 결재 기능이 있고, 현재 우리 서비스는 카카오 페이에 종속 적이게 개발이 되어 있음, 그러나 결제 모듈로 네이버 페이가 추가되어야함
    - 내 생각:
        1. 결제 기능을 담당하는 서비스를 인터페이스 화 & 카카오 페이 서비스 하는 리팩터링 진행 (리팩터링 스텝)
        2. 해당 서비스를 호출하는 구간에 대한 전략 패턴을 적용하는 리팩터링 진행 (리팩터링 스텝)
        3. 네이버 페이용 서비스 개발 (신규 기능 스텝)

  ⇒ 위와 같은 스텝으로 쪼갤 수 있을 듯 하며, 1번은 2개의 스텝으로 분리하는게 더 좋을끼 싶기도 한데 뭐가 맞는지 잘 모르겠다..

---

### 2.3 리팩터링하는 이유

- 리팩터링하면 소프트웨어 설계가 좋아진다
    - 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위한 코드 수정은 기반 구조를 무너뜨리기 쉬움
    - 기반 구조가 무너지게 되면, 코드를 보는 것 만으로는 설계를 파악하기가 어려워짐. ⇒ 이러한 악순환이 리팩터링을 하지 않을 경우 발생하게 된다.
    - **중복 코드 제거의 중요성**
        - 중복 코드 제거는 설계 개선 작업의 중요한 한 축이며, 중복 코드를 없앰으로서 모든 코드가 고유한 일을 수행함을 보장하는 것이 바람직한 설계의 핵심.
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
    - 추후에 내 코드를 보게될 사람 (주로 본인)을 위해서, 이해하기 쉬운 코드를 작성해야 그 사람의 작업 속도를 크게 개선할 수 있기 때문이다.
- 리팩터링하면 버그를 쉽게 찾을 수 있다
    - 아래와 같은 플로우로 버그를 발견할 수 있게 되는 듯 하다.
        - 리팩터링 진행 ⇒ 해당 코드의 목적/역할을 더 깊이 파악하게 됨 ⇒ 깨달은 내역을 다시 코드에 적용하려 수정 ⇒ 버그의 발견
- 리팩터링하면 프로그래밍 속도를 높일 수 있다
    - 설계가 나쁜 코드의 경우, 코드 베이스가 오래되면 오래 될 수록, 파악해야할 이전 히스토리는 많고 신규 기능의 사이드 이펙트도 많아짐.
        - 나쁜 설계: 시간이 흐름에 따라 기능의 누적 정도가 점점 더 어려워지게 됨.
    - 설계가 좋은 코드의 경우 오히려 코드 베이스가 오래되더라도 기존 코드를 활용함에 따라 새 기능의 추가가 훨씬 더 빨리 가능해짐.
        - 좋은 설계: 시간이 흐름에 따라 기능의 누적 정도가 점점 더 쉬워 짐.
    - 내부 설계의 완성도에 따라 소프트웨어에 신규 기능을 추가할 지점 && 수정할 지점을 찾는 것이 훨씬 더 용이해짐.
        - 이를 마틴 파울러는 **설계 지구력 가설(Design Stamina Hypothesis)라고 칭함**

---

### 2.4 언제 리팩터링해야 할까?

- 마틴 파울러는 프로그래밍을 할 때 한 시간 간격으로 리팩터링을 한다고 함.
- 돈 로버츠의 3의 법칙

    <aside>
    3️⃣

    1. 처음에는 그냥 한다
    2. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다
    3. 비슷한 일을 세 번째 하게 되면 리팩터링을 진행한다.
    </aside>

- 준비를 위한 리팩터링(Preparatory Refactoring): 기능을 쉽게 추가하게 만들기
    - **리팩터링하기 가장 좋은 시점: 새로운 기능을 새로 추가하기 직전 & 버그를 잡을 때**
        - 예시:
            - 기능 추가 / 버그 수정을 위해 기존 코드를 보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 쉬워지는 부분을 발견 ⇒ 요구 사항은 거의 만족하나, 리터럴 값 몇개가 방해되는 함수가 존재
            - 복붙하는 대신, 함수 매개변수화하기 기법을 활용해 리팩터링을 진행하면 매개변수를 지정해 호출하기만하면 된다!
        - 이러한 프로세스를 통해 버그가 수정된 상태를 오래 지속시킬 가능성을 높임 && 같은 곳에서의 버그 발생 확률을 줄일 수 있게됨.
    - 개인적인 경험으로는, 기존에 개발하기로 했던 시나리오가 변경되며, 기능에 변경점이 생긴 케이스에도 적용할 수 있을 듯 하다.
- 이해를 위한 리팩터링 (Comprehension Refactoring): 코드를 이해하기 쉽게 만들기
    - 리팩터링을 진행함으로서 본인을 포함 다른 개발자들도 시간이 지나고나서 확인해도 더 쉽게 이해할 수 있는 코드가 만들어진다는 것.
        - 리팩터링의 과정 중 해당 코드의 설계를 더 파악하게 되어 더 깊은 이해도를 가지게 된다.
        - 2.3 의 이해가기 쉬워진다와 일맥상통하는 내용.
- 쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)
    - 이해를 위한 리팩터링의 변형
    - 코드의 파악도 중 리팩터링이 필요해 보이는 구간에 도달했을 때, 리팩터링을 진행하는 행위를 말함
    - 마틴 파울러의 경우, 간단한 수정은 즉시 진행하고, 시간이 필요한 작업들은 메모를 남긴 후 (TODO 등?) 하던 일을 끝내고 나서 처리한다고 한다.
- 계획된 리팩터링과 수시로 하는 리팩터링
    - 위의 준비, 이해, 쓰레기 줍기 리팩터링은 모두 기회가 주어진 경우에만 할 수 있는 작업
    - 그러나 리팩터링은 프로그래밍을 하는 모든 지점에서 진행이 되어야 한다
    - 소프트웨어 개발을 `추가` 보다는 `수정` 을 잘하는 것이 작업 효율을 높이는 키가 될 수 있을 것이다가 마틴 파울러의 의견인 듯 하다.
    - 계획하고 진행하는 리팩터링이 나쁜 것은 아니지만, 상시 리팩터링을 진행할 수 있도록하여 시간을 내고 기회를 만들어서 진행하는 리팩터링을 줄이는 것이 좋다.
- 오래걸리는 리팩터링
    - 대부분의 리팩터링은 짧은 시간안에 진행되지만, 대규모로 진행해야하는 리팩터링도 존재한다
        - ex: 코어 라이브러리 교체, 코드 공유를 위해 컴포넌트화, 쌓여온 골치 아픈 의존성 정리
    - 그러나 저자는 이러한 상황이더라도 팀 전체가 리팩터링에 달려드는 것은 회의적인 듯 하다.
        - 이 보다는 문제의 세분화를 통해 조금씩 해결해 나가는 편이 더 효과적이라는 듯 하다.
        - 큰 덩어리의 문제를 세분화 하여 각 개인에게 부담하고, 각 개인은 주어진 내용에 대해 리팩터링을 진행하는 방식인 듯?
            - 리팩터링을 진행하여도 모든 기능은 기존과 동일하게 동작해야 하는 리팩터링의 특성을 활용하는 방식인 듯 하다.
        - ex: 라이브러리 교체시, 기존과 새 것 모두를 포용하는 추상 인터페이스를 만들어 기존 코드를 이 추상 인터페이스에 의존하도록 수정한 후 신규 라이브러리 교체 작업을 진행하면 작업이 훨씬 수월해진다. 이를 **추상화로 갈아타기 (Branch By
          Abstraction) 라 한다**
- 코드 리뷰에 리팩터링 활용하기
    - 다른이의 코드를 리뷰하며, 본인이 리팩터링을 진행한 후 어떻게 진행할 수 있을지를 고려해 보면, 더 좋은 리뷰를 남길 수 있게 된다.
    - 코드 리뷰에 리팩터링을 접목하는 방법은 리뷰의 성격에 따라 달라진다.
        - 일반적으로 git 을 이용하는 Pull request model 에는 적합하지 않은 것 같다고..
        - 참석해서 진행하는 방식이 좋다고 한다. 코드 작성자가 참석해 맥락을 설명해 줄 수 있고, 작성자도 리뷰러의 변경 의도를 제대로 이해할 수 있게 된다.
            - 이는 자연스러운 페어 프로그래밍이 된다.
    - *질문: 상시 리팩터링을 적용하기 위해선, 모든 팀원들이 코드 리뷰에 적극적으로 참여하고, 모든 인원이 동의하는 더 이해하기 쉬운 코드를 작성해야 할텐데 이에 대한 합의를 컨벤션으로 하는 것일까?*
        - 다른 분들의 경험이 궁금하다.
- 관리자에게는 뭐라고 말해야 할까?
    - 소프트웨어 개발자는 프로페셔널이다 (클린코더에서 이어지는 내용 같다). 그렇다면 프로답게 일해야 한다 (클린 코더에서 말하던 것 처럼, Saying No 할 수 있어야 한다는 의미)
        - 그렇기에 만약 **나의 관리자가 리팩터링이란 프로세스를 이해하지 못하는 관리자라면, ‘언급하지 말고 하라’** 가 마틴 파울러의 의견
        - **또한 안정정으로 돌아가는 코드를 만들기 위한 가장 빠른 방법은 리팩터링을 진행하는 방식이기에, 리팩터링을 하는 것이 더 프로페셔널한 방식**
- 리팩터링하지 말아야 할 때
    - **지저분한 코드라고 할지라도, 굳이 수정할 필요가 없다면 리팩터링하지 않는다**
        - 외부 API 다루듯 호출해서 쓰는 코드라면, 지저분하더라도 그냥 둔다.
            - 내부 동작을 이해해야하는 시점에 리팩터링을 진행해야 그 효과를 제대로 본다고 함.
    - **새로 작성하는 게 쉬울 때도 하지 않는다.**
        - ‘새로 작성하는게 쉽다’ 라는 결론을 내리는 방법에 대해선 저자도 쉽게 조언을 해주기 어렵다고 함..
            - 뛰어난 판단력과 경험이 뒷받침돼야 한다고만 말함.
        - *질문: 여러분들은 어떤 징조가 있을 때 새롭게 코드를 작성하는 쪽이 리팩터링하는 것 보다 쉽다는 느낌이 있었는지? 무엇을 기준으로 이런 판단을 내릴 수 있는지 다른 분들의 의견이 궁금합니다.*

---

### 2.5 리팩터링 시 고려할 문제

- 새 기능 개발 속도 저하
    - 리팩터링의 궁극적 목표는 개발 속도 향상에 있으나, 이를 공감하지 못하는 사람도 여전히 많다.
    - 항상 상황에 맞게 조율해야 한다. 그리고 이는 전적으로 경험을 기반으로 결정하는 것이 좋다
        - ex: 대대적 리팩터링이 필요해 보이지만, 추가하려는 기능이 단순하여 기능 추가부터 하고 싶은 상황이 있을 경우.
    - 새 기능을 개발하면서도 준비를 위한 리팩터링을 진행하면 변경을 훨씬 쉽게 할 수 있게 된다.
    - **리팩터링은 클린 코드 같은 도덕적 이유로 정당화 할 것이 아닌, 경제성과 효율성을 위해 반드시 진행해야하는 과정인 것이다.**
        - 이를 주변 동료들에게 널리 알림으로서, 팀의 개발 진행 그래프를 ‘좋은 설계’ 곡선으로 만들어야 한다.
- 코드 소유권
    - 리팩터링하고 싶은 코드가 다른 팀의 소유여서 내가 쉽게 건들기 어려운 경우나 변경하고 싶은 함수가 이미 고객에게 API로 제공된 것이라면 파악하기가 어려워짐.
        - 이러한 경우, 인터페이스를 복잡하게 만드는 한이 있더라도 사용하는 클라이언트에 영향을 주지 않아야한다.
    - 위와 같은 불편함이 존재할 수 있기에, 저자는 작은 단위로 코드 소유권을 관리하는데에 반대한다고 함.
- 브랜치
    - CI / TBD 방식의 개발이 리팩터링과의 궁합이 아주 좋다고 함.
        - 리팩터링의 장점을 온전히 살리기 위해선 짧은 배포 주기는 필수.
        - [git flow 이외에 다른 브랜치 전략에 대해서도 공부할 필요가 있어 보인다.](https://medium.com/daangn/매일-배포하는-팀이-되는-여정-1-브랜치-전략-개선하기-1a1df85b2cff)
- 테스팅
    - 리팩터링 중 실수를 저질러 기존 동작이 깨진 케이스를 빠르게 파악하고 잡는 방법 → 테스트
        - 이를 위해 자가 테스트 코드(self-testing code) 를 마련해야 함
        - 핵심은 **테스트가 실패했다면, 가장 최근에 통과한 버전에서 무엇이 달라졌는지 바로 확인이 가능하다는 점.**
    - 리팩터링 과정에선 버그가 생길 위험이 아주 크다 → 테스트가 필수인 이유
    - **자동 리팩터링 기능을 제공하는 환경이라면, 굳이 테스트가 필요없다고 한다.**
        - 사용할 수 있는 리팩터링 기법 수가 제한됨
        - 이러한 아이디어를 기반으로, 안전이 검증된 몇 가지 리팩터링 기법만 조합해서 사용하자는 흐름이 등장했다고 함.
            - 언어마다 방식의 차이가 크고, 각 단계마다 신중히 진행해야 하지만, 효과적으로 리팩터링 할 수 있음이 확인되었다고 한다.
            - 맛을 볼 수 있는 제이 바주지의 블로그 포스트: https://jay.bazuzi.com/Safely-extract-a-method-in-any-C++-code/
        - *질문: 이러한 방식으로 리팩터링을 진행해보신 경험이 있는 분이 계신지? 테스트 없이 리팩터링을 진행한다는 느낌이 어떤 느낌인지 아직 감이 오지 않는다.*
- 레거시 코드
    - 레거시 코드들의 가장 절망 포인트 ⇒ 테스트 코드의 부제
        - 이를 해결할 방법은? 테스트 보강! 즉 레거시 코드들을 위한 테스트 코드 작성.
            - 이에 대한 조언으론 **레거시 코드 활용 전략이라는 책을 읽어보라고만 함.**
            - 이런 레거시를 위한 테스트 코드를 작성하는데에도 리팩터링이 활용된다고 함.
    - 테스트가 존재하더라도, 레거시 코드의 리팩터링은 한번에 진행하기는 어렵다.
        - 저자의 방식은 관련된 부분끼리 나눠서 하나씩 쳐내가는 방법 (매 스텝마다 보이 스카우트 룰 적용!)
- 데이터베이스
    - 데이터베이스도 마찬가지로 리팩터링의 대상이 될 수 있고, 대표적으로는 컬럼의 변경 등의 작업이 있는 듯 하다.
    - 또 데이터 베이스의 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다.
        - 컬럼의 이름을 변경하는 경우의 프로세스는 다음과 같다:
            1. 새로운 데이터베이스 컬럼을 추가만 함 (사용 X)
            2. 기존 컬럼과 1에서 만든 컬럼을 동시에 업데이트 하도록 수정
            3. 버그 해결
            4. 클라이언트 교체 작업
            5. 필요없어진 예전 컬럼을 삭제
        - 이 방식을 병렬 수정 (parallel change) 또는 팽창-수축 (expand-contract) 라고 한다